/*
 * generated by Xtext
 */
package de.tu_bs.cs.isf.deltamsc.validation

import com.google.inject.Inject
import de.tu_bs.cs.isf.deltamsc.deltaMSC.Input
import de.tu_bs.cs.isf.deltamsc.deltaMSC.Testcase
import java.util.ArrayList
import java.util.List
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.resource.IContainer
import org.eclipse.xtext.resource.IResourceDescription
import org.eclipse.xtext.resource.IResourceDescriptions
import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider
import org.eclipse.xtext.validation.Check
import org.xtext.deltarx.deltarx.ConnectorTypeTwo
import org.xtext.deltarx.deltarx.Deltarx
import de.tu_bs.cs.isf.deltamsc.deltaMSC.DeltaMSCPackage
import org.xtext.deltarx.deltarx.ConnectorTypeOne

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class DeltaMSCValidator extends AbstractDeltaMSCValidator {

//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	@Inject
	ResourceDescriptionsProvider provider

	@Inject
	IContainer.Manager manager
	
	@Inject
	extension IQualifiedNameProvider
	
	var List<Deltarx> architectureList 

	/*
	 * @method Load all resources of the .darx files in the folder, where the .mymsc file is.
	 * @return A list with all resources of the .darx files
	 * 
	 */
	
	def List<Deltarx> getDeltarxResources(Resource r) {
		var List<Deltarx> resources = new ArrayList<Deltarx>()
		var IResourceDescriptions index = provider.createResourceDescriptions
		var List<IContainer> containers = manager.getVisibleContainers
				(index.getResourceDescription(r.getURI()), index)
		var ResourceSet rs = r.getResourceSet
		for(IContainer c: containers){
			for(IResourceDescription descriptions: c.resourceDescriptions){
				var Resource r2 = rs.getResource(descriptions.URI,true)
				if(r2.URI.fileExtension.equals("darx")){
					var darx = r2.allContents.filter(typeof(Deltarx))
					while(darx.hasNext){
						resources.add(darx.next)	
					}
				}		
			}	
		}		
		return resources
	}
	
	def Deltarx findArchitecture(String name) {
		for(architecture : architectureList){
			if(architecture.name.equals(name)) {
				return architecture;
			}
		}
		
		return null;
	}
//
//	@Check
//	def validateSameArchitectureInOneInput(Input input) {
//		if(input.first != null && input.second != null){
//			if(input.first.eContainer.fullyQualifiedName.toString != input.second.eContainer.fullyQualifiedName.toString){
//				error('The components have to be from the same architecture.', DeltaMSCPackage.Literals.INPUT__FIRST)	
//			}	
//		}
//	}
	
	@Check
	def validateSameArchitecture(Testcase test) {
		var String qualifiedName = null
		var int i=0
		for(inputs : test.inputs){
			if(inputs.first != null){
				if(qualifiedName == null){
					qualifiedName = inputs.first.eContainer.fullyQualifiedName.toString
				}else if(qualifiedName != inputs.first.eContainer.fullyQualifiedName.toString){
					error('The components have to be from the same architecture within the whole testcase.', DeltaMSCPackage.Literals.TESTCASE__INPUTS,i)
				}	
			}
			if(inputs.second != null){
				if(qualifiedName == null){
					qualifiedName = inputs.second.eContainer.fullyQualifiedName.toString
				}else if(qualifiedName != inputs.second.eContainer.fullyQualifiedName.toString){
					error('The components have to be from the same architecture within the whole testcase.', DeltaMSCPackage.Literals.TESTCASE__INPUTS,i)
				}	
			}
			if(qualifiedName == null){
					qualifiedName = inputs.signal.eContainer.fullyQualifiedName.toString
				}else if(qualifiedName != inputs.signal.eContainer.fullyQualifiedName.toString){
					error('The signals have to be from the same architecture within the whole testcase.', DeltaMSCPackage.Literals.TESTCASE__INPUTS,i)
				}
			i= i+1
		}
	}
	
	/*
	 * @method Check if the connector is specified in the Deltarx-File
	 * @return A list with all resources of the .darx files
	 * 
	 */
	
	@Check
	def validateConnectorTypeTwo(Input input){
		//If there is ENV specified, skip the check
		if(input.first == null || input.second == null)
		{
			return
		}
		//Get all resources
		architectureList = getDeltarxResources(input.eResource) 
		var Deltarx architecture = null	
		// Get the right architecture for the input					
		if(input.first != null){								
			architecture= findArchitecture(input.first.eContainer.fullyQualifiedName.toString)
		}else if(input.second != null){
			architecture= findArchitecture(input.second.eContainer.fullyQualifiedName.toString)
		}
		// Check if there is one connector which fullfill the condition. 
		for(connector : architecture.connectors){
			var connectorType = connector.type
			if(connectorType instanceof ConnectorTypeTwo){
				var connectorTypeTwo = connectorType as ConnectorTypeTwo
				if(input.first.name == connectorTypeTwo.source && 
					input.signal.name == connectorTypeTwo.sourcesignal &&
					input.second.name == connectorTypeTwo.destination
				){
					return
				}
			}
		}
		error('The connector is not specified', DeltaMSCPackage.Literals.INPUT__SIGNAL)		
	}
	
	def validateConnectorTypeOne(Input input){
		if(input.first == null || input.second == null)
		{
			return
		}
		architectureList = getDeltarxResources(input.eResource)
		var Deltarx architecture = null
		if(input.first != null){								
			architecture= findArchitecture(input.first.eContainer.fullyQualifiedName.toString)
		}else if(input.second != null){
			architecture= findArchitecture(input.second.eContainer.fullyQualifiedName.toString)
		}
		for(connector : architecture.connectors){
			var connectorType = connector.type
			if(connectorType instanceof ConnectorTypeOne){
				var connectorTypeOne = connectorType as ConnectorTypeOne
				if(input.first.name == connectorTypeOne.source && 
					input.signal.name == connectorTypeOne.signaltypeone &&
					input.second.name == connectorTypeOne.destination
				){
					return
				}
			}
		}
		error('The connector is not specified', DeltaMSCPackage.Literals.INPUT__SIGNAL)	
		
	}
	
	@Check
	def validateNamesWithNumbers(Input input){
		if(input.first != null){
			if (checkOfNumber(input.first.name)){
				error('The last/first char of the component name cannot be a number', DeltaMSCPackage.Literals.INPUT__FIRST)	
			}
		}
		if(input.second != null){
			if (checkOfNumber(input.second.name)){
				error('The last/first char of the component name cannot be a number', DeltaMSCPackage.Literals.INPUT__SECOND)	
			}
		}
		if (checkOfNumber(input.signal.name)){
			error('The last/first char of the signal name cannot be a number', DeltaMSCPackage.Literals.INPUT__SIGNAL)	
		}
	
	}
	
	def boolean checkOfNumber(String name){
		var char last = name.substring(name.length-1, name.length).toCharArray.get(0)
		if(last >= 48 && last<= 57){
			return true	
		}else{
			var char first = name.substring(0,1).toCharArray.get(0)
			if(first >= 48 && first<= 57){
				return true
			}
		}
		return false
	}
}
