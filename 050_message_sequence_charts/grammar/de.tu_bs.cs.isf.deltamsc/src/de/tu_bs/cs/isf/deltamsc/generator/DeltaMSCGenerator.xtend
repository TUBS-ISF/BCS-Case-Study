/*
 * generated by Xtext
 */
package de.tu_bs.cs.isf.deltamsc.generator

import com.google.inject.Inject
import de.tu_bs.cs.isf.deltamsc.deltaMSC.Input
import de.tu_bs.cs.isf.deltamsc.deltaMSC.Testcase
import java.util.ArrayList
import java.util.HashMap
import java.util.LinkedHashMap
import java.util.List
import java.util.Map
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.resource.IContainer
import org.eclipse.xtext.resource.IResourceDescription
import org.eclipse.xtext.resource.IResourceDescriptions
import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider
import org.xtext.deltarx.deltarx.Component
import org.xtext.deltarx.deltarx.Deltarx
import org.xtext.deltarx.deltarx.Signal

//import org.eclipse.emf.common.util.EList

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class DeltaMSCGenerator implements IGenerator {

	@Inject
	ResourceDescriptionsProvider provider

	@Inject
	IContainer.Manager manager
	@Inject
	extension IQualifiedNameProvider
	
	var List<Deltarx> architectureList 
	var Map<String, Integer> positionOfComponents
	var Map<String, String> labelOfComponents
	var Map<String, Integer> counterForComponents
//	var Iterable<Model> models
	var Testcase myModel
	var inputLineCount = 0
	var _hasEnv = false

	/*
	 * @method Main method for this class. 
	 * @return void
	 * 
	 */

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
//		architectureList = getDeltarxResources(resource)
////		println(architectureList.size)
//		//println(list)
//		 //Filter nach Typ
//		//	var Iterable models = resource.allContents.toIterable.filter[r | r.equals("")] //Filter nach bedingung
//		//	resource.allContents.toIterable.forEach[r | ]	//Führe für alle aus
//		//println("models: " + models.get(0).inputs.get(0).first.name)
////		models = resource.allContents.toIterable.filter(typeof(Model))
////		myModel = models.get(0)
//		for(testcase : resource.allContents.toIterable.filter(typeof(Testcase))){
//			myModel = testcase
//			var Deltarx architecture = getArchitecture(myModel)
//		//Loop through all architectures, to make for all the latex file.
//			//for(architecture : architectureList){
//				var archiName = architecture.name
//				hasEnv(myModel, archiName)
//				//Get labels for all components in the architecture.
//				getLabels(architecture)
//				//Create the map and calculate the positions of the components in the matrix.
//				setPositionOfComponent(architecture)
//				//Add all components to a map, to count later the labels in the matrix
//				addComponentsToMap(archiName)
//				if(positionOfComponents.size > 0){
//					inputLineCount = 0
//					//The filename of the latex file.
//					var filename = testcase.filename + ".tex"
//					//Generate the file and execute the compile-method.
//					fsa.generateFile(filename, myModel.compile(archiName, architecture.signals))
//				}
//			//}
//		}		
	}

	def Deltarx findArchitecture(String name) {
		for(architecture : architectureList){
			if(architecture.name.equals(name)) {
				return architecture;
			}
		}
		
		return null;
	}

	 def Deltarx getArchitecture(Testcase t){
		for(input : t.inputs){
			if(input.first != null){
				return findArchitecture(input.first.eContainer.fullyQualifiedName.toString)
			}else if(input.second != null){
				return findArchitecture(input.second.eContainer.fullyQualifiedName.toString)
			}	
		}
		
		return null
	}

	
	/*
	 * @method Load all resources of the .darx files in the folder, where the .mymsc file is.
	 * @return A list with all resources of the .darx files
	 * 
	 */
	
	def List<Deltarx> getDeltarxResources(Resource r) {
		var List<Deltarx> resources = new ArrayList<Deltarx>()
		var IResourceDescriptions index = provider.createResourceDescriptions
		var List<IContainer> containers = manager.getVisibleContainers
				(index.getResourceDescription(r.getURI()), index)
		var ResourceSet rs = r.getResourceSet
		for(IContainer c: containers){
			for(IResourceDescription descriptions: c.resourceDescriptions){
				var Resource r2 = rs.getResource(descriptions.URI,true)
				if(r2.URI.fileExtension.equals("darx")){
					var darx = r2.allContents.filter(typeof(Deltarx))
					while(darx.hasNext){
						resources.add(darx.next)	
					}
				}		
			}	
		}		
		return resources
	}
	
	/*
	 * @method A method to filter just the input lines for the current architecture. Used in a .filter() function.
	 * @return True if the input line is for the current architecture.
	 * 
	 */
	def String getSignalName(Signal signal){
		if(signal == null) {
			return 'tick'	
		}
		return signal.name
	}
	
	def String getLowerCaseSignalName(Signal signal){
		return getSignalName(signal).toLowerCase
	}
	def boolean filterInputs(Input inp, String arch){	
		return (inp.first != null && inp.first.eContainer.fullyQualifiedName.toString == arch) ||
			(inp.second != null && inp.second.eContainer.fullyQualifiedName.toString == arch)
	}
	
	/*
	 * @method Here the template for the latex file is compiled. The blue text is the static text 
	 * and the other text is to generate the dynamic lines.
	 * @return The String with all the generated informations.
	 * 
	 */
	
	def String compile(Testcase m, String architectureName, List<Signal> signals) {
		'''
		\documentclass{article}
		\usepackage{tikz}
		%%%<
		\usepackage{verbatim}
		\usepackage[active,tightpage]{preview}
		\PreviewEnvironment{tikzpicture}
		\setlength\PreviewBorder{5pt}%
		
		\usetikzlibrary{shapes.geometric}
		\begin{document}
		\pagestyle{empty}
		
		% Components
		
		«FOR com : positionOfComponents.keySet»
			\def\«com.toLowerCase»{«com»}
		«ENDFOR»
		
		% Signals
		    \def\tick{tick}
		    \def\tickUnder{tick}
		«FOR sig: signals»
			\def\«getLowerCaseSignalName(sig).replaceAll("_", "")»{«getSignalName(sig).replaceAll("_", "")»}
			\def\«getLowerCaseSignalName(sig).replaceAll("_", "")»Under{«getSignalName(sig).replaceAll("_", "\\\\_")»}
		«ENDFOR»
		
		% Diagram
		\begin{tikzpicture}[every node/.style={font=\normalsize,
		minimum height=0.5cm,minimum width=0.5cm},]
		
		% Matrix
		
		\node [matrix, very thin,column sep=1.3cm,row sep=0.5cm] (matrix) at (0,0) {
			«FOR comp : positionOfComponents.keySet» «
			»\node(0,0) (\«comp.toLowerCase») {}; «
				»«IF positionOfComponents.get(comp) < positionOfComponents.size -1»«
					»& &  «
				»«ELSE»«
					»& \\ «
				»«ENDIF»«
			»«ENDFOR»
			«FOR inputs : myModel.inputs.filter[filterInputs(architectureName)]»
				«getInputLine(inputs.first, inputs.second, getSignalName(inputs.signal))»
			«ENDFOR»«
			»
			«FOR comp : positionOfComponents.keySet» «
			»\node(0,0) (\«comp.toLowerCase» «inputLineCount») {}; «
				»«IF positionOfComponents.get(comp) < positionOfComponents.size -1» «
					»& &  «
				»«ELSE» «
					»& \\ «
				»«ENDIF» «
			»«ENDFOR»};
		
		
		%% Agents labels
		\fill 
			«FOR node: positionOfComponents.keySet»
				«IF !node.equals("ENV")»
				(\«node.toLowerCase») node[draw,fill=white] {\«node.toLowerCase»}«
				»«ENDIF»
			«ENDFOR»«
			»;
		
		%% Vertical lifelines  
		\draw [dashed]
			«FOR node: positionOfComponents.keySet»
				«IF !node.equals("ENV")»	
				(\«node.toLowerCase») -- (\«node.toLowerCase» «inputLineCount»)
				«ENDIF»
			«ENDFOR»«
			»;
		
		\draw«
		»«var lineCounter = -1»
			«FOR inputs : myModel.inputs.filter[filterInputs(architectureName)]»
				
				(\«getComponentName(inputs.first).toLowerCase» «lineCounter = lineCounter + 1») node[draw,circle,fill=white,inner sep = 2.1mm] {} node {$l_{«labelOfComponents.get(getComponentName(inputs.first))»}^«getCounterForComponents(getComponentName(inputs.first))»$}
				(\«getComponentName(inputs.second).toLowerCase» «lineCounter») node[draw,circle,fill=white,inner sep = 2.1mm] {} node {$l_{«labelOfComponents.get(getComponentName(inputs.second))»}^«getCounterForComponents(getComponentName(inputs.second))»$}«
			»«ENDFOR»;
			
		%% Horizontal Messages
		«var secondLineCounter = -1»
			«FOR inputs : myModel.inputs.filter[filterInputs(architectureName)]»
				\draw [-latex,shorten <=0.5mm, shorten >=0.5mm] (\«getComponentName(inputs.first).toLowerCase» «secondLineCounter = secondLineCounter + 1») -- (\«getComponentName(inputs.second).toLowerCase» «secondLineCounter»);
			«ENDFOR»
			
		% Flows Labels
		\fill
			«
		»«var signalCounter = -1»
			«FOR inputs : myModel.inputs.filter[filterInputs(architectureName)]»
				(\«getLowerCaseSignalName(inputs.signal).replaceAll("_", "")» «signalCounter = signalCounter + 1»)
					node[font=\footnotesize,above] {\«getLowerCaseSignalName(inputs.signal).replaceAll("_", "")»Under}
			«ENDFOR»;	

		\end{tikzpicture}
		\end{document}
		'''
	}
	
	/*
	 * @method This one calculate the position of the components and write it into a LinkedHashMap.
	 * The key is the name of the component and the value the position of the component in the matrix.
	 * @return void
	 * 
	 */
	 
	def setPositionOfComponent(Deltarx architecture){
		var position = 0
		positionOfComponents = new LinkedHashMap<String, Integer>()
		if(_hasEnv){
			positionOfComponents.put("ENV", position)
			position = position + 1
		}
		for (inp : myModel.inputs.filter[filterInputs(architecture.name)]){
			if(inp.first != null){	
				if(!positionOfComponents.containsKey(inp.first.name)){
					positionOfComponents.put(inp.first.name, position)
					position = position + 1
				}		
			} 
			if(inp.second != null){ 
				if(!positionOfComponents.containsKey(inp.second.name)){
					positionOfComponents.put(inp.second.name, position)
					position = position + 1
				} 	
			}	
		}	
	}	
	
	/*
	 * @method Writes all components in a HashMap
	 * @return void
	 * 
	 */
	 
	def addComponentsToMap(String architectureName){
		counterForComponents = new LinkedHashMap<String, Integer>()
		counterForComponents.put("ENV",0)
		for (inp : myModel.inputs.filter[filterInputs(architectureName)]){
				if(inp.first != null && !counterForComponents.containsKey(inp.first.name)){
					counterForComponents.put(inp.first.name, 0)
				}
				if(inp.second != null && !counterForComponents.containsKey(inp.second.name)){
					counterForComponents.put(inp.second.name, 0)
				}  
		}		
	}
	
		/*
	 * @method This method returns the name for the component, to validate if its ENV or not. 
	 * @return String for the conmponent name
	 * 
	 */
	def String getComponentName(Component comp){
		if(comp == null){
			return "ENV"	
		}
		return comp.name
		
	}
	
	/*
	 * @method This method makes the string for the current input line 
	 * to write it to the matrix. 
	 * @return String for the input line for the matrix
	 * 
	 */
	
	def String getInputLine(Component firstComponent, Component secondComponent, String signal){
		 //Calculate the position of the component that comes first in the matrix. And the max position in of the components.
		var firstComponentName = getComponentName(firstComponent)
		var secondComponentName = getComponentName(secondComponent)
		var posFirst = positionOfComponents.get(firstComponentName)    
		var posSecond = positionOfComponents.get(secondComponentName)
		var minPos = Math.min(posFirst, posSecond)
		var maxPos = Math.max(posFirst, posSecond)
		var inputLine = ""
		//Clone for minPos, so this will not change.
		var _minPosLeft = minPos
		var differenceOfPos = maxPos - minPos
		//Add '& &' until the min position is reached.
		while(_minPosLeft>0){
			inputLine =inputLine + " & &"
			_minPosLeft = _minPosLeft-1
		}															
		if(posFirst == minPos){
			inputLine = inputLine + " \\node(0,0) (\\"+firstComponentName.toLowerCase+" "+ inputLineCount +") {};"
		}else {
			inputLine = inputLine + " \\node(0,0) (\\"+secondComponentName.toLowerCase+" "+ inputLineCount +") {};"	
		}
		var firstTime = true
		//For the difference between min and max position add behind the first '&' the signal and then so many '& &' until the next component 
		while(differenceOfPos > 0){
			if(firstTime){
				inputLine = inputLine + " & \\node(0,0) (\\"+ signal.replaceAll("_", "")+" "+ inputLineCount +") {}; &"
				firstTime = false
			}
			else{
				inputLine = inputLine + " & &"
			}
			differenceOfPos = differenceOfPos -1
		}
		//If the first component is not the one with the min position write it here else write the second component
		if(posFirst != minPos){
			inputLine = inputLine + " \\node(0,0) (\\"+firstComponentName.toLowerCase+" "+ inputLineCount +") {};"
		}else {
			inputLine = inputLine + " \\node(0,0) (\\"+secondComponentName.toLowerCase+" "+ inputLineCount +") {};"	
		}
		//The second component must not be the last one in the matrix, so add '& &' until the last position is reached.
		var trailing = positionOfComponents.size - maxPos - 1
		while(trailing > 0){
			inputLine =inputLine + " & &"
			trailing = trailing -1
		}
		inputLineCount = inputLineCount + 1
		// Return the calculated inputLine plus '& \\'.
		return inputLine + " & \\\\ \n "
		
	}
	
	/*
	 * @method Set the label of the components. 
	 * @return void
	 * 
	 */
	
	def getLabels(Deltarx architecture){
		var componentsOfArchitecure = architecture.components
		labelOfComponents = new HashMap<String, String>()
		if(_hasEnv){
			labelOfComponents.put("ENV","e")	
		}
		for(comp : componentsOfArchitecure){
			//split the first letter of the components name
			var firstLetter = comp.name.substring(0 , 1).toLowerCase
			if(!labelOfComponents.containsValue(firstLetter)){
				labelOfComponents.put(comp.name, firstLetter)		
			}
		}	
	}
	
	/*
	 * @method Calculate the number of the label
	 * @return 
	 * 
	 */
	 
	def int getCounterForComponents(String component){
		var labelNumber = counterForComponents.get(component)
		var newValue = counterForComponents.get(component) + 1
		counterForComponents.put(component, newValue)
		return labelNumber
	}
	
	def hasEnv(Testcase m, String architectureName){
		for(input : m.inputs.filter[filterInputs(architectureName)]){
			if(input.first == null){
				_hasEnv = true	
				return
			}
			else if(input.second == null){
				_hasEnv = true	
				return
			}
		}	
	}

}
